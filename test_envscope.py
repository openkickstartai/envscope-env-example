"""Tests for EnvScope core analysis engine."""
import os
import pytest
from envscope import (
    scan_file, parse_env_file, find_dead, find_orphans,
    find_inconsistent, generate_example, EnvRef,
)


def _write(path, content):
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w") as f:
        f.write(content)
    return path


def test_scan_python(tmp_path):
    p = _write(str(tmp_path / "app.py"), '\n'.join([
        'import os',
        'db = os.getenv("DATABASE_URL", "sqlite:///db")',
        'key = os.environ["SECRET_KEY"]',
        'port = os.environ.get("PORT", "8080")',
    ]))
    refs = scan_file(p)
    names = {r.name for r in refs}
    assert names == {"DATABASE_URL", "SECRET_KEY", "PORT"}
    assert next(r for r in refs if r.name == "DATABASE_URL").default == "sqlite:///db"
    assert next(r for r in refs if r.name == "PORT").default == "8080"
    assert next(r for r in refs if r.name == "SECRET_KEY").default is None


def test_scan_javascript(tmp_path):
    p = _write(str(tmp_path / "server.js"), '\n'.join([
        'const port = process.env.PORT || 3000;',
        'const host = process.env["DB_HOST"];',
    ]))
    refs = scan_file(p)
    assert {r.name for r in refs} == {"PORT", "DB_HOST"}


def test_scan_go(tmp_path):
    p = _write(str(tmp_path / "main.go"), '\n'.join([
        'package main',
        'import "os"',
        'func main() {',
        '    key := os.Getenv("API_KEY")',
        '    debug, _ := os.LookupEnv("DEBUG")',
        '}',
    ]))
    refs = scan_file(p)
    assert {r.name for r in refs} == {"API_KEY", "DEBUG"}


def test_scan_typescript(tmp_path):
    p = _write(str(tmp_path / "config.ts"), 'const url = process.env.API_URL;\n')
    refs = scan_file(p)
    assert len(refs) == 1
    assert refs[0].name == "API_URL"


def test_parse_env_file(tmp_path):
    p = _write(str(tmp_path / ".env"), '# db config\nDATABASE_URL=postgres://localhost/db\nPORT=3000\n')
    refs = parse_env_file(p)
    assert {r.name for r in refs} == {"DATABASE_URL", "PORT"}
    assert next(r for r in refs if r.name == "PORT").default == "3000"


def test_parse_env_skips_comments(tmp_path):
    p = _write(str(tmp_path / ".env"), '# SKIP_ME=yes\nKEEP_ME=true\n')
    refs = parse_env_file(p)
    assert len(refs) == 1
    assert refs[0].name == "KEEP_ME"


def test_find_dead():
    defs = [EnvRef("USED", ".env", 1, kind="def"), EnvRef("ZOMBIE", ".env", 2, kind="def")]
    reads = [EnvRef("USED", "app.py", 10)]
    dead = find_dead(reads, defs)
    assert len(dead) == 1
    assert dead[0].name == "ZOMBIE"


def test_find_dead_empty():
    defs = [EnvRef("A", ".env", 1, kind="def")]
    reads = [EnvRef("A", "x.py", 1)]
    assert find_dead(reads, defs) == []


def test_find_orphans():
    defs = [EnvRef("DB", ".env", 1, kind="def")]
    reads = [EnvRef("DB", "a.py", 1), EnvRef("MISSING", "b.py", 2)]
    orphans = find_orphans(reads, defs)
    assert len(orphans) == 1
    assert orphans[0].name == "MISSING"


def test_find_orphans_deduplicates():
    defs = []
    reads = [EnvRef("X", "a.py", 1), EnvRef("X", "b.py", 5)]
    orphans = find_orphans(reads, defs)
    assert len(orphans) == 1


def test_find_inconsistent():
    reads = [
        EnvRef("PORT", "a.py", 1, default="8080"),
        EnvRef("PORT", "b.py", 5, default="3000"),
    ]
    result = find_inconsistent(reads)
    assert "PORT" in result
    assert {r.default for r in result["PORT"]} == {"8080", "3000"}


def test_no_inconsistent_when_same_default():
    reads = [
        EnvRef("PORT", "a.py", 1, default="8080"),
        EnvRef("PORT", "b.py", 5, default="8080"),
    ]
    assert find_inconsistent(reads) == {}


def test_generate_example():
    reads = [
        EnvRef("DATABASE_URL", "app.py", 10),
        EnvRef("PORT", "app.py", 15, default="8080"),
    ]
    output = generate_example(reads)
    assert "DATABASE_URL=" in output
    assert "PORT=8080" in output
    assert "REQUIRED" in output
    assert "optional" in output
    assert "Auto-generated by EnvScope" in output


def test_unsupported_extension_returns_empty(tmp_path):
    p = _write(str(tmp_path / "data.csv"), 'a,b,c\n1,2,3\n')
    assert scan_file(p) == []
